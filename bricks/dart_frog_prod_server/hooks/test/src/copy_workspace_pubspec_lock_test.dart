import 'dart:io';

import 'package:dart_frog_prod_server_hooks/dart_frog_prod_server_hooks.dart';
import 'package:mason/mason.dart';
import 'package:mocktail/mocktail.dart';
import 'package:path/path.dart' as path;
import 'package:test/test.dart';

class _MockHookContext extends Mock implements HookContext {}

class _MockLogger extends Mock implements Logger {}

void main() {
  group('copyWorkspacePubspecLock', () {
    late List<int> exitCalls;
    late HookContext context;
    late Logger logger;
    late Directory buildDirectory;
    late Directory workingDirectory;

    setUp(() {
      exitCalls = [];
      context = _MockHookContext();
      logger = _MockLogger();
      buildDirectory = Directory.systemTemp.createTempSync('build');
      workingDirectory = Directory.systemTemp.createTempSync('working');

      when(() => context.logger).thenReturn(logger);

      addTearDown(() {
        buildDirectory.delete().ignore();
        workingDirectory.delete().ignore();
      });
    });

    test('exits with error when unable to determine the workspace root', () {
      copyWorkspacePubspecLock(
        context,
        buildDirectory: buildDirectory.path,
        workingDirectory: workingDirectory.path,
        exit: exitCalls.add,
      );
      expect(exitCalls, equals([1]));
      verify(
        () => logger.err(
          'Unable to determine workspace root for ${workingDirectory.path}',
        ),
      );
    });

    test('exits with error when unable to parse pubspec.yaml', () {
      File(path.join(workingDirectory.path, 'pubspec.yaml'))
          .writeAsStringSync('invalid pubspec.yaml');
      copyWorkspacePubspecLock(
        context,
        buildDirectory: buildDirectory.path,
        workingDirectory: workingDirectory.path,
        exit: exitCalls.add,
      );
      expect(exitCalls, equals([1]));
      verify(
        () => logger.err(
          'Unable to determine workspace root for ${workingDirectory.path}',
        ),
      );
    });

    test('does nothing when pubspec.lock does not exist in workspace root', () {
      File(path.join(workingDirectory.path, 'pubspec.yaml'))
          .writeAsStringSync('''
name: _
version: 0.0.0
environment:
  sdk: ^3.8.0
workspace:
  - packages/hello_world
''');
      copyWorkspacePubspecLock(
        context,
        buildDirectory: buildDirectory.path,
        workingDirectory: workingDirectory.path,
        exit: exitCalls.add,
      );
      expect(exitCalls, isEmpty);
      verifyNever(() => logger.err(any()));
      expect(buildDirectory.listSync(), isEmpty);
    });

    test('exits with error when unable to copy lockfile', () {
      const pubspecLockContents = '''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
''';
      File(path.join(workingDirectory.path, 'pubspec.yaml'))
          .writeAsStringSync('''
name: _
version: 0.0.0
environment:
  sdk: ^3.8.0
workspace:
  - packages/hello_world
''');
      final file = File(path.join(workingDirectory.path, 'pubspec.lock'))
        ..writeAsStringSync(pubspecLockContents);
      Process.runSync('chmod', ['000', file.path]);
      copyWorkspacePubspecLock(
        context,
        buildDirectory: buildDirectory.path,
        workingDirectory: workingDirectory.path,
        exit: exitCalls.add,
      );
      expect(exitCalls, equals([1]));
      verify(
        () => logger.err(any(that: contains('Permission denied'))),
      );
    });

    test('copies pubspec.lock to build directory when found', () {
      const pubspecLockContents = '''
# Generated by pub
# See https://dart.dev/tools/pub/glossary#lockfile
packages:
''';
      File(path.join(workingDirectory.path, 'pubspec.yaml'))
          .writeAsStringSync('''
name: _
version: 0.0.0
environment:
  sdk: ^3.8.0
workspace:
  - packages/hello_world
''');
      File(path.join(workingDirectory.path, 'pubspec.lock'))
          .writeAsStringSync(pubspecLockContents);
      copyWorkspacePubspecLock(
        context,
        buildDirectory: buildDirectory.path,
        workingDirectory: workingDirectory.path,
        exit: exitCalls.add,
      );
      expect(exitCalls, isEmpty);
      verifyNever(() => logger.err(any()));
      final buildDirectoryContents = buildDirectory.listSync();
      expect(buildDirectoryContents, hasLength(1));
      expect(
        buildDirectoryContents.first,
        isA<File>().having(
          (f) => path.basename(f.path),
          'name',
          'pubspec.lock',
        ),
      );
      expect(
        (buildDirectoryContents.first as File).readAsStringSync(),
        equals(pubspecLockContents),
      );
    });
  });
}
